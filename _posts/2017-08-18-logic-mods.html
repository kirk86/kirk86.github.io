---
layout: post
title: "Logic"
date: 2017-08-18
comments: true
maths: true
tags: logic
excerpt: Logic rules
---

<p>
<b>Logic Rules</b>
</p>

<ul class="org-ul">
<li>Modus Ponens: If A then B</li>
<li>Moduls Tollens: If not B then not A</li>

<li>9 Axioms of set theory from Prof. Fredric Schuller</li>
</ul>
<p>
&#x2013; E
&#x2013; E
</p>

<p>
&#x2013; P
&#x2013; U
&#x2013; R
&#x2013; P
</p>

<p>
&#x2013; I
&#x2013; C
</p>

<p>
&#x2013; F
</p>

<p>
All of modern mathematics can be grounded without making any
conceptual assumptions except for the inclusion relation (a.k.a. the
epsilon relation or \(\epsilon\)–Relation) in axiomatic set
theory. To this concept are add nine axioms which allow to build up
the machinery for the advanced mathematics that theoretical physics
uses. To formulate these axioms propositional and predicate logic
provide the symbolic language we use. The nine axioms can be
abbreviated as <b><b>EE PURP
IC F</b></b>:
</p>

<p>
<b><b>Basic Existence Axioms</b></b>
</p>

<p>
<b><b>E1: The Axiom on \(\epsilon-Relation \)</b></b>
</p>

<p>
\(\forall x \forall y (x\in y) \veebar \neg (x\in y)\)
</p>

<p>
\(x\in y\) is a proposition if and only if \(x\) and \(y\) are both sets.
</p>


<p>
<b><b>E2: Axiom of Existence of an Empty Set</b></b>
</p>

<p>
\(\exists x \forall y: y\notin x\)
</p>

<p>
There exists a set \(x\) such that for all \(y\) it is true that \(y\) is not an
element of \(x\). That is, there exists an empty set, a set that contains
no elements.
</p>


<p>
<b><b>Construction Axioms</b></b>
</p>

<p>
<b><b>P1: Axiom on Pair Sets</b></b>
</p>

<p>
\(\forall x \forall y \exists m \forall u (u\in m\leftrightarrow u=x,  u=y)\)
</p>

<p>
Let \(x\) and \(y\) be sets. Then there exists a set that contains as its
elements precisely the sets \(x\) and \(y\). Or: For all \(x\) and for all \(y\),
there exists a set \(m\), such that for all \(u\), \(u\) is an element of \(m\) if and
only if \(u\) is \(x\) or \(u\) is \(y\).
</p>

<p>
<b><b>U: Axiom on Union Sets</b></b>
</p>

<p>
Let \(x\) be a set. Then there exists a set \(u\) whose elements are precisely
the elements of the elements of \(x\).
</p>

<p>
\(\forall x \exists y \forall c (c\in y \leftrightarrow\exists z (c\in z \wedge z\in x))\)
</p>

<p>
<b><b>R: Axiom of Replacement</b></b>
</p>

<p>
\(\exists x\forall y \in a(\exists z  A(y, z)\rightarrow\exists z\in x A(y, z) )\)
</p>

<p>
Let \(R\) be a functional relation. Let \(m\) be a set. Then the image of \(m\)
under the functional relation \(R\) is again a set.
</p>


<p>
<b><b>P2: Axiom on Existence of Power Sets</b></b>
</p>

<p>
\(\forall \exists p \forall y (y\in p\leftrightarrow\forall z  (z\in y\rightarrow z\in x))\)
</p>

<p>
Let \(m\) be a set. There exists a set denoted \(\mathbf{P}(m)\) whose elements are
precisely the subsets of \(m\).
</p>

<p>
<b><b>Further Existence/Construction Axioms</b></b>
</p>

<p>
<b><b>I: Axiom of Infinity</b></b>
</p>

<p>
\(\exists m (\emptyset\in m \wedge \forall x\in m((x\cup {x}\in m)))\)
</p>

<p>
There exists a set that contains the empty set and with every of its
elements \(y\) it also contains the set with the element \(y\) (or \({y}\)) as an
element.
</p>

<p>
<b><b>C: Axiom of Choice</b></b>
</p>

<p>
\(\forall X((\forall x\in X\forall y\in X(x=y\leftrightarrow x\cap y\ne\emptyset))\rightarrow\exists z(\forall x\in X\exists ! y y\in x\cap z))\)
</p>

<p>
if you have a collection \(X\) of pairwise disjoint non-empty sets, then
you get a set \(z\) which contains one element from each set in the
collection. [Schuller, using different formulae: Let \(x\) be a set whose
elements are non-empty and mutually disjoint, then there exists a set
\(y\) which contains exactly one element of each element of \(x\).]
</p>


<p>
<b><b>Non-Existence Axiom</b></b>
</p>


<p>
<b><b>F: Axiom of Foundation</b></b>
</p>

<p>
\(x\neq\emptyset\rightarrow\exists y(y\in x\wedge y\cap x=\emptyset)\)
</p>

<p>
Every nonempty set is disjunct from one of its elements. [Schuller:
Every non-empty set \(x\) contains an element \(y\) that has none of its
elements in common with \(x\).]
</p>


<p>
Differential geometry works with space, and space is made of sets
of points. So to study these things, we first will need to look at
what sets are. But set theory itself cannot be the absolute foundation.
 Try to define a set, for example as a
collection of elements, we would need some other concepts
(which presumably we cannot assume at this foundational level); for
example, how do we define a “collection” and an “element”? The way we
will get around this is by constructing set theory on the basis of
axioms rather than on such definitions. But in order to formulate
these axioms, we first need a language, in this case, of propositional
and predicate logic.  [Note, while it may seem that Schuller will
define the terms or concepts in propositional and predicate logic, he
in fact uses a logical operator, the biconditional, which is
understood merely in terms of its truth functionality, and what is
being biconditionally combined are most basically just mechanically
operable symbols.]
</p>

<p>
What could the first definition be? For a definition you need notions
that you already have in order to define a new notion. But if you do
not have any notion yet, how would you start? The trick is to start
axiomatically, and so we will have to write out axiomatic set
theory. But that then raises the question, in what language would you
possibly do that? So, actually before we come to set theory, we need
another building block down here, and that would be logic. And we will
deal with propositional and predicate logic first. That will define
our language. Then we will be able to write down the axioms of set
theory. (quoting Schuller, 0.08.30 - 0.09.15)
</p>

<p>
<b><b>Relations over a set</b></b>
</p>

<p>
If \(X = Y\) then we simply say that the binary relation is over \(X\), or
that is an <code>endorelation</code> over \(X\). In CS, such a relation is called a
homogeneous (binary) relation. Some types of <code>endorelations</code> are
widely studied in graph theory, where they are known simple as
directed graphs permitting loops.
</p>

<p>
The set of binary relations \(\mathbf{\mbox{Rel}}(X)\) on a set \(X\) is
the set \(2^{X\times X}\) which is a Boolean algebra augmented with the
<code>inovlution</code> of mapping of a relation to its <code>inverse</code> relation.
</p>

<p>
Some important properties that a binary relation \(R\) over as set \(X\)
may have are:
</p>

<ul class="org-ul">
<li><code>reflexive</code>: \(\forall x\in X\) it holds that \(xRx\). For example
"greater than or equal to" (\(\ge\)) is a reflexive relation but
"greater than" (&gt;) is not.</li>

<li><code>irreflexive</code> (or <code>strict</code>): \(\forall x\in X\) it holds that <code>not</code>
\(xRx\). For example, \(>\) is an irreflexive relation, but \(\ge\) is
not.</li>

<li><code>coreflexive relation</code>: \(\forall x\wedge y\in X\) it holds that if
\(xRy\) then \(x=y\). An example of a <code>coreflexive</code> relation is the
relation on integers in which each odd number is related to itself
and there are no other relations. The equality relation is the only
example of a both reflexive and coreflexive relation, and any
coreflexive relation is a subset of teh identity relation.</li>

<li><code>symmetric</code>: \(\forall x\wedge y\in X\) it holds that if \(xRy\) then
\(yRx\). "Is a blood relative of" is a symmetric relation, because \(x\)
is a blood relative of \(y\rightleftarrow y\) if a blood relative of
\(x\)</li>

<li><code>antisymmetric</code>: \(\forall x\wedge y\in X\), if \(xRy\) and \(yRx\) then
\(x=y\). For example, \(\ge\) is <code>anti-symmetric</code>; so is \(>\), but
vacuously (the condition in the definition is always false).</li>

<li><code>asymmetric</code>: \(\forall x\wedge y\in X\), if \(xRy\) then <code>not</code> \(yRx\). A
relation is <code>asymmetic</code> if and only if it is <code>both anti-symmetric
  and irreflexive</code>. For example, \(>\) is asymmetic, but \(\ge\) is not.</li>

<li><code>transitive</code>: \(\forall x, y\wedge z\in X\) it holds taht if \(xRy\) and
\(yRz\) then \(xRz\). For example, "is ancestor of" is transitive, while
"is parent of" is not. A transitive relation is irreflexive
\(\rightleftarrow\) it is asymmetric.</li>

<li><code>total</code>: \(\forall x\wedge y\in X\) it holds that \(xRy\) or \(yRz\) (or
both) then \(xRz\). This definition of <code>total</code> is different from <code>left
  total</code> in the previous section. For example, \(\ge\) is a total
relation.</li>

<li><code>trichotomous</code>: \(\for all x\wedge y\in X\) exactly one of \(xRy\),
\(yRx\) or \(x=y\) holds. For example, \(>\) is a trichotomous relation,
while the relation "divides" on natural numbers is not.</li>

<li><code>Right Euclidean</code>: \(\for all x, y\wedge z\in X\) it holds that if
\(yRx\) and \(zRx\). then \(yRz\)</li>

<li><code>Left Euclidean</code>: \(\forall x, y\wedge z\in X\) it holds that if \(yRx\)
and \(zRx\), then \(yRz\).</li>

<li><code>Euclidean</code>: A Euclidean relation is both left and right
Euclidean. Equality is a Euclidean relation because if \(x=y\wedge
  x=z\), then \(y=z\).</li>

<li><code>serial</code>: \(\forall x\in X\exists y: xRy\), "Is greater than" is a
serial relation on the integers. But it is not a serial relation on
the positive integers, because there is no \(y\) in the positive
integers such that 1&gt;y. However, "is less than" is a serial relation
on the positive integers, the rational numbers and the real
numbers. Every reflexive relation is serial: for a given \(x\), choose
\(y=x\). A serial relation can be equivalently characterized as every
element having a non-empty successor neighborhood (see the previous
section for the definition of this notion). Similarly an inverse
serial relation is a relation in which every element has non-empty
predecessor neighborhood.</li>

<li><code>set-like (or local)</code>: \(\forall x\in X\), the class of all \(y\) such
that \(yRx\) is a set. (This makes sense only if relations on proper
classes are allowed.) The usual ordering \(<\) on the class of ordinal
numbers is set-like, while its inverse \(>\) is not.</li>
</ul>

<p>
A relation that is reflexive, symmetric, and transitive is called an
<code>equivalence relation</code>. A relation that is symmetric, transitive, and
serial is also reflexive. A relation that is only symmetric and
transitive (without necessarily being reflexive) is called a <code>partial
equivalence relation</code>.
</p>

<p>
A relation that is reflexive, antisymmetric, and transitive is called
a <code>partial order</code>. A partial order that is total is called a <code>total
order</code>, simple order, linear order, or a chain.[25] A linear order
where every nonempty subset has a <code>least element</code> is called a
<code>well-order</code>.
</p>

<p>
<code>Binary endorelations by property</code>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">reflexivity</th>
<th scope="col" class="org-left">symmetry</th>
<th scope="col" class="org-left">transitivity</th>
<th scope="col" class="org-left">symbol</th>
<th scope="col" class="org-left">example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">directed graph</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\(\rightarrow\)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">undirected graph</td>
<td class="org-left">\(X\)</td>
<td class="org-left">\(\checkmark\)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">tournament</td>
<td class="org-left">\(X\)</td>
<td class="org-left">antisymmetric</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">pecking order</td>
</tr>

<tr>
<td class="org-left">dependency</td>
<td class="org-left">\(\checkmark\)</td>
<td class="org-left">\(\checkmark\)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">strict weak order</td>
<td class="org-left">irreflexive</td>
<td class="org-left">antisymmetric</td>
<td class="org-left">\(\checkmark\)</td>
<td class="org-left">\(<\)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">total preorder</td>
<td class="org-left">\(\checkmark\)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\(\checkmark\)</td>
<td class="org-left">\(le\)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">preorder</td>
<td class="org-left">\(\checkmark\)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\(\checkmark\)</td>
<td class="org-left">\(\le\)</td>
<td class="org-left">preference</td>
</tr>

<tr>
<td class="org-left">partial order</td>
<td class="org-left">\(\checkmark\)</td>
<td class="org-left">antisymmetric</td>
<td class="org-left">\(\checkmark\)</td>
<td class="org-left">\(\le\)</td>
<td class="org-left">subset</td>
</tr>

<tr>
<td class="org-left">partial equivalence</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\(\checkmark\)</td>
<td class="org-left">\(\checkmark\)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">equivalence relation</td>
<td class="org-left">\(\checkmark\)</td>
<td class="org-left">\(\checkmark\)</td>
<td class="org-left">\(\checkmark\)</td>
<td class="org-left">\(-,=,\approx,\cong,\equiv\)</td>
<td class="org-left">equality</td>
</tr>

<tr>
<td class="org-left">strict partial order</td>
<td class="org-left">\(X\)</td>
<td class="org-left">\(X\)</td>
<td class="org-left">\(\checkmark\)</td>
<td class="org-left">\(<\)</td>
<td class="org-left">proper subset</td>
</tr>
</tbody>
</table>


<p>
<b><b>Operations on Binary Relations</b></b>
</p>
